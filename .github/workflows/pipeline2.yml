name: Post-Deployment Pipeline

# on:
#   workflow_dispatch: # manual trigger
#   workflow_run:
#     workflows: ["Deploy Pipeline"]
#     types:
#       - completed
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # ----------------- DAST -----------------
  dast:
    name: DAST Scan - OWASP ZAP
    # if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: development
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Debug secret
        run: |
          if [ -z "${{ secrets.STAGING_URL }}" ]; then
            echo "STAGING_URL is empty"
            exit 1
          else
            echo "STAGING_URL is set"
          fi

      - name: Test connectivity
        run: curl -I ${{ secrets.STAGING_URL }}

      - name: Run OWASP ZAP baseline scan
        run: |
          docker run --user root --rm \
            -v $(pwd):/zap/wrk/:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t "${{ secrets.STAGING_URL }}" \
            -r zap-report.html \
            -d || true

      - name: Upload HTML report artifact
        uses: actions/upload-artifact@v4
        with:
          name: zap-html-report
          path: zap-report.html

  # ----------------- JMETER -----------------
  jmeter:
    name: Load Test - Apache JMeter
    # if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: development
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install JMeter
        run: |
          sudo apt-get update -y
          sudo apt-get install -y openjdk-17-jre-headless
          wget https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.6.3.tgz
          tar -xzf apache-jmeter-5.6.3.tgz
          mv apache-jmeter-5.6.3 /opt/jmeter
          export PATH=$PATH:/opt/jmeter/bin

      - name: Run all JMeter Test Plans
        run: |
          mkdir -p jmeter-results jmeter-report
          chmod -R 777 jmeter-results jmeter-report

          for test in jmeter/tests/*.jmx; do
            name=$(basename "$test" .jmx)
            echo "üöÄ Running JMeter test: $name"
            /opt/jmeter/bin/jmeter -n \
              -t "$test" \
              -Jtarget_host=${{ secrets.STAGING_URL }} \
              -l "jmeter-results/${name}.jtl" \
              -e -o "jmeter-report/${name}" || true
          done

      - name: Upload JMeter Reports
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-reports
          path: jmeter-report/

  # ----------------- AI SUMMARY -----------------
  ai-implementation:
    name: AI Implementation
    runs-on: ubuntu-latest
    environment: development
    needs: [dast, jmeter]
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download ZAP report artifacts
        uses: actions/download-artifact@v4
        with:
          name: zap-html-report
          path: ./reports

      - name: Download JMeter report artifacts
        uses: actions/download-artifact@v4
        with:
          name: jmeter-reports
          path: ./jmeter-report

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-genai html2text beautifulsoup4

      - name: Analyze ZAP Report with Gemini
        id: gemini_summary
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          python - <<'END'
          import os
          import html2text
          import google.genai
          from google.genai.errors import ServerError
          import time
          from bs4 import BeautifulSoup
          from collections import Counter

          os.environ["GOOGLE_API_KEY"] = os.environ["GEMINI_API_KEY"]
          REPORT_FILE = "./reports/zap-report.html"

          if not os.path.isfile(REPORT_FILE):
              print("ZAP report not found!")
              exit(1)

          with open(REPORT_FILE, "r", encoding="utf-8") as f:
              html_content = f.read()
          
          soup = BeautifulSoup(html_content, "html.parser")
          risk_cells = soup.find_all(string=lambda s: s and any(r in s for r in ["Critical", "High", "Medium", "Low", "Informational"]))
          levels = []
          for text in risk_cells:
              t = text.strip().lower()
              if "critical" in t: levels.append("Critical")
              elif "high" in t: levels.append("High")
              elif "medium" in t: levels.append("Medium")
              elif "low" in t: levels.append("Low")
              elif "informational" in t: levels.append("Informational")

          counts = Counter(levels)
          print("ZAP Risk Counts:", counts)

          report_text = html2text.html2text(html_content)
          client = google.genai.Client()

          summary_prompt = f"""
          Summarize this OWASP ZAP report.

          Issue counts:
          Critical: {counts.get('Critical', 0)}
          High: {counts.get('High', 0)}
          Medium: {counts.get('Medium', 0)}
          Low: {counts.get('Low', 0)}
          Informational: {counts.get('Informational', 0)}

          Provide:
          - A short overall risk summary
          - Top recurring issues
          - Any recommendations to improve security posture

          Report content:
          {report_text}
          """

          # retry logic for 503 errors
          for attempt in range(5):
              try:
                  response = client.models.generate_content(
                      model="gemini-2.0-flash",
                      contents=summary_prompt,
                  )
                  break
              except ServerError as e:
                  if e.status_code == 503:
                      print(f"Gemini model overloaded, retrying in {5*(attempt+1)}s...")
                      time.sleep(5*(attempt+1))
                  else:
                      raise
          else:
              print("Failed to get response after retries.")
              response = type("R", (), {"text": "Gemini API unavailable."})()

          with open("gemini_summary.txt", "w", encoding="utf-8") as f:
              f.write("ZAP Risk Counts:\n")
              for level in ["Critical", "High", "Medium", "Low", "Informational"]:
                  f.write(f"{level}: {counts.get(level, 0)}\n")
              f.write(response.text)
          END

      - name: Export Gemini summary
        shell: bash
        run: |
          echo "GEMINI_SUMMARY<<EOF" >> $GITHUB_ENV
          cat gemini_summary.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Post Gemini summary as commit comment
        uses: actions/github-script@v7
        env:
          COMMIT_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commitSha = process.env.COMMIT_SHA
            const summary = process.env.GEMINI_SUMMARY || "No AI summary available."
            const runId = process.env.GITHUB_RUN_ID
            const commentBody = `
            ### ü§ñ Gemini AI ZAP + JMeter Analysis (Commit)

            <details>
            <summary>Click to expand AI-generated summary</summary>

            \`\`\`
            ${summary}
            \`\`\`

            </details>

            üìä [View ZAP & JMeter Artifacts](../../TutorLink/actions/runs/${runId})
            `
            if (!commitSha) {
              console.log("‚ö†Ô∏è No commit SHA found ‚Äî skipping comment.")
              return
            }
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commitSha,
              body: commentBody
            })
            console.log(`‚úÖ Gemini summary posted to commit ${commitSha}`)

