name: Post-Deployment Pipeline

on:
  workflow_dispatch: # manual trigger
  workflow_run:
    workflows: ["Deploy Pipeline"]
    types:
      - completed

jobs:
  # ----------------- DAST -----------------
  dast:
    name: DAST Scan - OWASP ZAP
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: development
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Debug secret
        run: |
          if [ -z "${{ secrets.STAGING_URL }}" ]; then
            echo "STAGING_URL is empty"
            exit 1
          else
            echo "STAGING_URL is set"
          fi

      - name: Test connectivity
        run: curl -I ${{ secrets.STAGING_URL }}

      - name: Run OWASP ZAP baseline scan
        run: |
          docker run --user root --rm \
            -v $(pwd):/zap/wrk/:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t "${{ secrets.STAGING_URL }}" \
            -r zap-report.html \
            -d || true

      - name: Upload HTML report artifact
        uses: actions/upload-artifact@v4
        with:
          name: zap-html-report
          path: zap-report.html

  # ----------------- JMETER -----------------
  jmeter:
    name: Load Test - Apache JMeter
    runs-on: ubuntu-latest
    environment: development
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install JMeter
        run: |
          sudo apt-get update -y
          sudo apt-get install -y openjdk-17-jre-headless
          wget https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.6.3.tgz
          tar -xzf apache-jmeter-5.6.3.tgz
          mv apache-jmeter-5.6.3 /opt/jmeter
          export PATH=$PATH:/opt/jmeter/bin

      - name: Run all JMeter Test Plans
        run: |
          mkdir -p jmeter-results jmeter-report
          chmod -R 777 jmeter-results jmeter-report

          for test in jmeter/tests/*.jmx; do
            name=$(basename "$test" .jmx)
            echo "üöÄ Running JMeter test: $name"
            /opt/jmeter/bin/jmeter -n \
              -t "$test" \
              -Jtarget_host=${{ secrets.STAGING_URL }} \
              -l "jmeter-results/${name}.jtl" \
              -e -o "jmeter-report/${name}" || true
          done

      - name: Upload JMeter Reports
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-reports
          path: jmeter-report/

  # ----------------- AI SUMMARY -----------------
  ai-implementation:
    name: AI Implementation
    runs-on: ubuntu-latest
    environment: development
    needs: [dast, jmeter]
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download ZAP report artifacts
        uses: actions/download-artifact@v4
        with:
          name: zap-html-report
          path: ./reports

      - name: Download JMeter report artifacts
        uses: actions/download-artifact@v4
        with:
          name: jmeter-reports
          path: ./jmeter-report

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-genai html2text

      - name: Analyze ZAP Report with Gemini
        id: gemini_summary
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          python - <<'END'
          import os
          import html2text
          import google.genai
          from google.genai.errors import ServerError
          import time

          os.environ["GOOGLE_API_KEY"] = os.environ["GEMINI_API_KEY"]
          REPORT_FILE = "./reports/zap-report.html"

          if not os.path.isfile(REPORT_FILE):
              print("ZAP report not found!")
              exit(1)

          with open(REPORT_FILE, "r", encoding="utf-8") as f:
              html_content = f.read()

          report_text = html2text.html2text(html_content)
          client = google.genai.Client()

          # retry logic for 503 errors
          for attempt in range(5):
              try:
                  response = client.models.generate_content(
                      model="gemini-2.5-flash",
                      contents=f"Summarize the following ZAP scan report and key load test insights:\n\n{report_text}",
                  )
                  break
              except ServerError as e:
                  if e.status_code == 503:
                      print(f"Gemini model overloaded, retrying in {5*(attempt+1)}s...")
                      time.sleep(5*(attempt+1))
                  else:
                      raise
          else:
              print("Failed to get response after retries.")
              response = type("R", (), {"text": "Gemini API unavailable."})()

          with open("gemini_summary.txt", "w", encoding="utf-8") as f:
              f.write(response.text)
          END

      - name: Export Gemini summary (safe for multiline)
        run: |
          {
            echo 'GEMINI_SUMMARY<<EOF'
            cat gemini_summary.txt
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: Post Gemini summary as commit comment
        uses: actions/github-script@v7
        env:
          COMMIT_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commitSha = process.env.COMMIT_SHA
            const summary = process.env.GEMINI_SUMMARY || "No AI summary available."
            const runId = process.env.GITHUB_RUN_ID
            const commentBody = `
            ### ü§ñ Gemini AI ZAP + JMeter Analysis (Commit)

            <details>
            <summary>Click to expand AI-generated summary</summary>

            \`\`\`
            ${summary}
            \`\`\`

            </details>

            üìä [View ZAP & JMeter Artifacts](../../actions/runs/${runId})
            `
            if (!commitSha) {
              console.log("‚ö†Ô∏è No commit SHA found ‚Äî skipping comment.")
              return
            }
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commitSha,
              body: commentBody
            })
            console.log(`‚úÖ Gemini summary posted to commit ${commitSha}`)

